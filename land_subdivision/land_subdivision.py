# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LandSubdivision
                                 A QGIS plugin
 This plugin subdivides a piece of land from blocks to parcels , and ensures egress to each parcel.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-10-03
        git sha              : $Format:%H$
        copyright            : (C) 2023 by MGC SOFTWARE SOLUTIONS
        email                : mulyungivick09@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon, QColor
from qgis.PyQt.QtWidgets import *
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox
from PyQt5.QtCore import QVariant, Qt, pyqtSignal, pyqtSlot
from qgis.utils import iface
from qgis.core import (QgsProject, QgsGeometry, QgsPoint, QgsPointXY, QgsWkbTypes, 
    QgsFeatureRequest, QgsVectorLayer, QgsDistanceArea, QgsUnitTypes, 
    QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsFeature, QgsField, QgsExpression, QgsFields,
    QgsExpressionContext, QgsExpressionContextUtils, edit, QgsVectorDataProvider, QgsMessageLog, Qgis )
from qgis.core import *
from qgis.gui import *
from qgis.gui import QgsMapTool, QgsRubberBand
import processing
import math
import numpy as np

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
#from .land_subdivision_dialog import LandSubdivisionDialog
from .subdivision_dialog import SubDivDialog
import os.path


class LandSubdivision:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'LandSubdivision_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Land Subdivider')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        #Initializing the subdivision parameters
        self.memory_sides = None
        self.memory_adjacents = None
        #self.vertices_layer = None

        #initialize the storage of the coordinates
        #self.dlg.mLineEdit.textChanged.connect(self.incomingRoad)

        # #create an attribute canvas to refer to the map canvas
        # self.canvas = iface.mapCanvas()
        # #create an attribute MapTool that refers to the instance
        # #of the custom subclass of the QgsMapTool i.e., the ParcelMapTool
        # self.mapTool = ParcelMapTool(self.canvas)
        # #connect the signal (called: drawingDone) to the slot method "vertices"
        # self.mapTool.drawingDone.connect(self.vertices)
        # self.mapTool.parcelDrawn.connect(self.explode_lines)
        


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('LandSubdivision', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/land_subdivision/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Algorithm to subdivide land'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Land Subdivider'),
                action)
            self.iface.removeToolBarIcon(action)


    def acresToSqm(self):
        self.acres = self.dlg.dsbDesired_Area.value()
        self.lot_Width = self.dlg.dsbLot_Width.value()
        # one acre = 4046.85642 square meters
        self.areaSqm = self.acres * 4046.85642
        return self.areaSqm

    def calculate_Length(self):
        if self.lot_Width != 0:
            self.lot_Length = self.areaSqm / self.lot_Width
            QgsMessageLog.logMessage(f"The Desired area of {self.acres} acres in square meters is: {self.areaSqm} m²", 'LandSubdivision:Info. Tab', level = Qgis.Info)
            QgsMessageLog.logMessage(f"The length for a width of {self.lot_Width} m is: {self.lot_Length} m", 'LandSubdivision:Info. Tab', level = Qgis.Info)
            return self.lot_Length
        else:
            QgsMessageLog.logMessage("Error: Length should be non-zero for valid calculation.", 'LandSubdivision:Info. Tab', level = Qgis.Info)
            return None


    def vertices(self):
        layer = self.dlg.cbParcel.currentLayer()
        #bounds_result = processing.run("native:orientedminimumboundingbox", {"INPUT":layer, "OUTPUT":"TEMPORARY_OUTPUT"})["OUTPUT"]
        vertices_result = processing.run("native:extractvertices", {"INPUT":layer, "OUTPUT":"TEMPORARY_OUTPUT"})["OUTPUT"]
        QgsProject.instance().addMapLayer(vertices_result)
        return (vertices_result)
     
    def vertex_coordinates(self):
        
        coordinates = self.vertices()
        coords = [] 
        features = coordinates.getFeatures()
        for feature in features:
            geom = feature.geometry()
            x, y = geom.asPoint().x(), geom.asPoint().y()
            coords.append(QgsPointXY(x, y))
        logMsg = "Vertex Cordinates:"
        for c in coords:
            logMsg += f"({c.x()}, {c.y()})\n"
        QgsMessageLog.logMessage(logMsg, 'LandSubdivision:Info. Tab', level=Qgis.Info)
        return coords
        
        # Define a slot function that will store the input value in a variable in the main python file
    #@pyqtSlot(str)
    def incomingRoad(self):
        layer = self.dlg.cbParcel.currentLayer()
        layerCrs = layer.crs().authid()
        crs = QgsCoordinateReferenceSystem(layerCrs)
        
        # Fetch Coordinates for your road feature from the QtWidgets
        self.fCoord = self.dlg.mLineEdit.value()
        self.sCoord = self.dlg.mLineEdit_2.value()
    
        #create a list to store split coords from the first string coords
        self.value1 =[]
        for x in self.fCoord.split(','):
            #convert them to float values
            y =float(x)
            self.value1.append(y)

        #create a list to store split from the second string coordinates
        self.value2 = []
        for i in self.sCoord.split(','):
            #convert them to float values
            j = float(i)
            self.value2.append(j)
        

        '''testLand 1-4'''
        # self.fCoord = 37.0110277, -1.1101208
        # self.sCoord = 37.0109037, -1.1102909
        '''STUDY AREA Geocentric'''
        # self.fCoord = 37.053088,-1.232891
        # self.sCoord = 37.052882, -1.232595
        # '''STUDY AREA UTM'''
        # self.fCoord = 283365.35, 9863649.11
        # self.sCoord = 283342.32, 9863681.79

        fCoord1 = QgsPointXY(self.value1[0], self.value1[1])
        sCoord1 = QgsPointXY(self.value2[0], self.value2[1])

        # Create the LineString layer and add the road features
        roadLayer = QgsVectorLayer("LineString", 'Roads', "memory", crs=crs)
        road_pr = roadLayer.dataProvider()
        roadLayerGeom = QgsGeometry.fromPolylineXY([fCoord1, sCoord1])
        roadFeature = QgsFeature()
        roadFeature.setGeometry(roadLayerGeom)
        road_pr.addFeatures([roadFeature])
        QgsProject.instance().addMapLayer(roadLayer)

        # Extend the road
        splitLine = processing.run("native:extendlines", {"INPUT": roadLayer, "START_DISTANCE": 5, "END_DISTANCE": 5, "OUTPUT": "TEMPORARY_OUTPUT"})["OUTPUT"]
        #QgsProject.instance().addMapLayer(splitLine)

        # Split the parcel layer with the extended road
        splitResult = processing.run("native:splitwithlines", {"INPUT": layer, "LINES": splitLine, "OUTPUT": "TEMPORARY_OUTPUT"})["OUTPUT"]
        #QgsProject.instance().addMapLayer(splitResult)
        # Create a MultiPolygon layer to hold the split polygons
        multiPolyLayer = QgsVectorLayer("MultiPolygon", 'Split Polygons', "memory", crs=crs)
        
        multiPoly_pr = multiPolyLayer.dataProvider()
        #add a field "ID" to label the split polygons
        multiPoly_pr.addAttributes([QgsField("ID", QVariant.Int)])
        multiPolyLayer.updateFields()

        splitResult_pr = splitResult.dataProvider()
        splitResult_pr.addAttributes([QgsField("ID", QVariant.Int)])
        splitResult.updateFields()
        expression = QgsExpression("$id")
        

        with edit(splitResult):
            for f in splitResult.getFeatures():
                context = QgsExpressionContext()
                context.appendScopes(\
                QgsExpressionContextUtils.globalProjectLayerScopes(splitResult))
                context.setFeature(f)
                f["ID"] = expression.evaluate(context)
                splitResult.updateFeature(f)

        # Use the splitResult layer to iterate through the split polygons
        for feature in splitResult.getFeatures():
            # Extract vertices
            coords = feature.geometry().asPolygon()[0]
            # Create a new polygon feature for each split polygon
            polygons = QgsFeature()
            # Set the geometry for the polygon feature
            polygons.setGeometry(QgsGeometry.fromPolygonXY([coords]))
            # Add the polygon feature to the MultiPolygon layer
            multiPoly_pr.addFeatures([polygons])
        # Add the MultiPolygon layer to the project
        #QgsProject.instance().addMapLayer(multiPolyLayer)
        return multiPolyLayer

    def show_qgis_message(self, title, message):
        iface.messageBar().pushMessage(title, message, level=Qgis.Critical, duration=10)

    def Vertex(self, multiPolyLayer):
        try:
            #Extract vertices of split polygons
            splitVertices = processing.run("native:extractvertices", {"INPUT": multiPolyLayer, "OUTPUT": "TEMPORARY_OUTPUT"})["OUTPUT"]
            QgsProject.instance().addMapLayer(splitVertices)
            pr = splitVertices.dataProvider()
            
            #add field to store coordinates in attribute table
            for attr in ["Latitude", "Longitude"]:
                pr.addAttributes([QgsField(attr, QVariant.Double)])
                splitVertices.updateFields()
                #in order to allow the expression to access the feature’s field values; create a QgsExpressionContext
            exp = QgsExpression('"attr"')
            context = QgsExpressionContext()
            #access the features i.e., feat.
            for feat in splitVertices.getFeatures():
                fields = splitVertices.fields()
                attrs = {
                    fields.indexFromName("Latitude"):feat.geometry().asPoint()[0],
                    fields.indexFromName("Longitude"):feat.geometry().asPoint()[1]
                }
                pr.changeAttributeValues({feat.id(): attrs})
                context.setFeature(feat)
                exp.evaluate(context)
            splitVertices.updateFields()
                

            pr.addAttributes([QgsField("ID", QVariant.Int)])
            splitVertices.updateFields()

            
            expression = QgsExpression("$id")
            context = QgsExpressionContext()
            context.appendScopes(\
            QgsExpressionContextUtils.globalProjectLayerScopes(splitVertices))

            with edit(splitVertices):
                for f in splitVertices.getFeatures():
                    context.setFeature(f)
                
                    f["ID"] = expression.evaluate(context)
                    splitVertices.updateFeature(f)

            # Extract vertices
            vertices = []
            for feat in splitVertices.getFeatures():
                geom = feat.geometry()
                k = geom.asPoint()
                vertices.append(k)

            # Define the ranges of IDs you want to extract
            self.id25 = range(2, 6)  # IDs 2-5
            self.id710 = range(7, 11)  # IDs 6-10

            # Extract X and Y coordinates for the specified ID ranges
            vertices25 = [QgsPointXY(vertex.x(), vertex.y()) for i, vertex in enumerate(vertices) if (i + 1) in self.id25]
            vertices710 = [QgsPointXY(vertex.x(), vertex.y()) for i, vertex in enumerate(vertices) if (i + 1) in self.id710]
            

            # Print out the vertices in the two groups
            #delete the QgsPointXY() object from vertices25 and vertices710 respectively to print out the coordinates
            # QgsMessageLog.logMessage(f"Vertices with IDs 2 to 5: {vertices25}", 'LandSubdivision:Info. Tab', level=Qgis.Info)
            # QgsMessageLog.logMessage(f"Vertices with IDs 6 to 10: {vertices710}", 'LandSubdivision:Info. Tab', level=Qgis.Info)

            #calculate the lengths
            d = QgsDistanceArea()
            crs = QgsCoordinateReferenceSystem()
            context = QgsProject.instance().transformContext()
            d.setSourceCrs(crs, context)
            d.setEllipsoid('WGS84')

            #POLYGON1
            self.pt2 = vertices25[0] #id = 2
            self.pt2_x = vertices25[0].x()
            self.pt2_y = vertices25[0].y()
            self.pt3 = vertices25[1] #id = 3
            self.pt3_x = vertices25[1].x()
            self.pt3_y = vertices25[1].y()
            self.pt4 = vertices25[2] #id = 4
            self.pt4_x = vertices25[2].x()
            self.pt4_y = vertices25[2].y()
            self.pt5 = vertices25[3] #id = 5
            self.pt5_x = vertices25[3].x()
            self.pt5_y = vertices25[3].y()

            self.l1 = d.measureLine(self.pt2, self.pt3)
            self.l2 = d.measureLine(self.pt3, self.pt4)
            self.l3 = d.measureLine(self.pt4, self.pt5)
            self.l4 = d.measureLine(self.pt5, self.pt2)
            

            QgsMessageLog.logMessage(f"l1: {self.l1}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
            QgsMessageLog.logMessage(f"l2: {self.l2}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
            QgsMessageLog.logMessage(f"l3: {self.l3}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
            QgsMessageLog.logMessage(f"l4: {self.l4}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
            
            #POLYGON2
            self.pt7 = vertices710[0] #id = 7
            self.pt7_x = vertices710[0].x()
            self.pt7_y = vertices710[0].y()
            self.pt8 = vertices710[1] #id = 8                                                                                                                                                                                             
            self.pt8_x = vertices710[1].x()
            self.pt8_y = vertices710[1].y()
            self.pt9 = vertices710[2] #id = 9
            self.pt9_x = vertices710[2].x()
            self.pt9_y = vertices710[2].y()
            self.pt10 = vertices710[3] #id = 10
            self.pt10_x = vertices710[3].x()
            self.pt10_y = vertices710[3].y()

            self.l5 = d.measureLine(self.pt7, self.pt8)
            self.l6 = d.measureLine(self.pt8, self.pt9)
            self.l7 = d.measureLine(self.pt9, self.pt10)
            self.l8 = d.measureLine(self.pt10, self.pt7)

            
            QgsMessageLog.logMessage(f"l5: {self.l5}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
            QgsMessageLog.logMessage(f"l6: {self.l6}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
            QgsMessageLog.logMessage(f"l7: {self.l7}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
            QgsMessageLog.logMessage(f"l8: {self.l8}", 'LandSubdivision:Info. Tab', level = Qgis.Info)




            self.lot_Width = self.dlg.dsbLot_Width.value()
            #self.lot_Length = self.dlg.dsbLot_Length.value()
            if self.l1 > self.l2:
                if self.l1 >= self.l3:
                    self.long_axis = self.l1
                else:
                    self.long_axis = self.l3
                if self.l2 <= self.l4:
                    self.short_axis = self.l2
                else:
                    self.short_axis = self.l4
                self.c = round(self.long_axis/(self.lot_Length))
                self.e = round(self.short_axis/self.lot_Width)
            else: 
                if self.l2 >= self.l4:
                    self.long_axis = self.l2
                else:
                    self.long_axis = self.l4
                if self.l1 <= self.l3:
                    self.short_axis = self.l1
                else:
                    self.short_axis = self.l3
                self.c = round((self.long_axis/self.lot_Length))
                self.e = round((self.short_axis/self.lot_Width))

            a = ((self.c-1)* self.lot_Length) # primary road offset length
            r = self.long_axis - a #remaining distance
            if r < self.lot_Length:
                y = ((self.c-2)* self.lot_Length) #road offset length for reminder < width
                self.n = round((self.long_axis/self.lot_Length))
                self.lengthDist = self.long_axis/self.n
                QgsMessageLog.logMessage(f"PRIMARY: LotLength is now {self.lengthDist}", 'CHECK', level = Qgis.Info)   


                QgsMessageLog.logMessage(f"PRIMARY: Reminder is less than the Lot Length", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"PRIMARY: Length [n] offsets : {self.n}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"PRIMARY: Road Offset [y] Length: {y}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            elif r > self.lot_Length:
                y = ((self.c-1)* self.lot_Length)
                self.n = round((self.long_axis/self.lot_Length)+1) #road offset length for remainder > width 
                self.lengthDist = self.long_axis/self.n
                QgsMessageLog.logMessage(f"Lot Length is now: {self.lengthDist}", 'CHECK', level = Qgis.Info)
                QgsMessageLog.logMessage(f"PRIMARY: Reminder is not less than the Lot Length", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"PRIMARY: Primary Road Offset Length: {y}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"PRIMARY: Length [n] offsets +1 : {self.n}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   

            QgsMessageLog.logMessage(f"Long Axis L: {self.long_axis}", 'LandSubdivision:Info. Tab', level=Qgis.Info)
            QgsMessageLog.logMessage(f"Short_axis L: {self.short_axis}", 'LandSubdivision:Info. Tab', level=Qgis.Info)
            

            b = ((self.e-1)* self.lot_Width) # primary road offset length
            f = self.short_axis - b #remaining distance
            if f < self.lot_Width:
                h = ((self.e-2)* self.lot_Width) #road offset length for reminder < width
                self.m = round((self.short_axis/self.lot_Width))
                self.widthDistb = self.short_axis/self.m
                QgsMessageLog.logMessage(f"Lot Width [L] is now: {self.widthDistb}", 'CHECK', level = Qgis.Info)   

                QgsMessageLog.logMessage(f"LEFT: Reminder is less than the Lot Width: {f}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"LEFT: Length offsets : {self.m}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"LEFT: Primary Road Offset Length(To the LEFT): {h}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            elif f > self.lot_Width:
                h = ((self.e-1)* self.lot_Width) #road offset length for remainder > width 
                self.m = round((self.short_axis/self.lot_Width) +1)
                self.widthDistb = self.short_axis/self.m
                QgsMessageLog.logMessage(f"Lot Width is [L] now: {self.widthDistb}", 'CHECK', level = Qgis.Info)

                QgsMessageLog.logMessage(f"LEFT: Reminder is not less than the Lot Width: {f}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"LEFT: Primary Road Offset Length(To the L    EFT): {h}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"LEFT: Length offsets [m]: {self.m}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            QgsMessageLog.logMessage(f"LEFT: Width [m] : {self.m}", 'LandSubdivision:Info. Tab', level=Qgis.Info)
            #QgsMessageLog.logMessage(f"Length n offsets: {self.n}", 'LandSubdivision:Info. Tab', level=Qgis.Info)
                
            if self.l5 > self.l6:
                if self.l5 >= self.l7:
                    self.longAxis = self.l5
                else:
                    self.longAxis = self.l7
                if self.l6 <= self.l8:
                    self.shortAxis = self.l6
                else:
                    self.shortAxis = self.l8
                self.o = round((self.longAxis/self.lot_Length))
                self.w = round((self.shortAxis/self.lot_Width))
            else: 
                if self.l6 >= self.l8:
                    self.longAxis = self.l6
                else:
                    self.longAxis = self.l8
                if self.l5 <= self.l7:
                    self.shortAxis = self.l5
                else:
                    self.shortAxis = self.l7
                self.o = round((self.longAxis/self.lot_Length))
                self.w = round((self.shortAxis/self.lot_Width))
            
            QgsMessageLog.logMessage(f"LongAxis R: {self.longAxis}", 'LandSubdivision:Info. Tab', level=Qgis.Info)
            QgsMessageLog.logMessage(f"ShortAxis R: {self.shortAxis}", 'LandSubdivision:Info. Tab', level=Qgis.Info)        

            k =  ((self.w - 1)* self.lot_Width)
            j = self.shortAxis - k #reminder distance at offset determination
            if j < self.lot_Width:
                self.l = ((self.w-2)* self.lot_Width) #primary offset legnth to the Right
                self.p = round((self.shortAxis/self.lot_Width)) 
                self.widthDist = self.shortAxis/self.p
                QgsMessageLog.logMessage(f"Lot Width [R] is now : {self.widthDist}", 'CHECK', level = Qgis.Info)
                QgsMessageLog.logMessage(f"RIGHT: Reminder is less than the Lot Width: {j}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"RIGHT: Widths[p]  offsets : {self.p}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"RIGHT: Primary Road Offset Length: {self.l}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            elif j > self.lot_Width:
                self.l = ((self.w-1)* self.lot_Width)
                self.p = round((self.shortAxis/self.lot_Width) +1)
                self.widthDist = self.shortAxis/self.p
                QgsMessageLog.logMessage(f"Lot Width [R] is now: {self.widthDist}", 'CHECK', level = Qgis.Info)
                QgsMessageLog.logMessage(f"RIGHT: Widths [p+]  offsets : {self.p}", 'LandSubdivision:Info. Tab', level=Qgis.Info)
                QgsMessageLog.logMessage(f"RIGHT: Reminder is not less than the Lot Width: {j}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
                QgsMessageLog.logMessage(f"RIGHT: Primary Road Offset Length(RIGHT): {self.l}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            
            self.centreline()
        except IndexError:
            # Handle the out-of-range error and display a message to the user
            self.show_qgis_message("O-O-R Error", "Kindly ensure your road Coordinates represent a line feature is incident to the Polygon. PROGRAM HAS TERMINATED")
            iface.unloadPlugin("Land Subdivider")

        except Exception as e:
            # Handle other exceptions if needed
            print(f"An error occurred: {e}")
            self.show_qgis_message("Error", f"An error occurred: {e}")
        return splitVertices
    

        
        

    def blockPartition(self):
        try:
            multiPolyLayer = self.incomingRoad()
            self.lot_width = self.dlg.dsbLot_Width.value()
            #self.lot_length = self.dlg.dsbLot_Length.value()
            layer = self.dlg.cbParcel.currentLayer()
            self.Vertex(multiPolyLayer)
            layerCrs = layer.crs().authid()
            crs = QgsCoordinateReferenceSystem(layerCrs)
            QgsMessageLog.logMessage("Partition Running", 'LandSubdivision:Info. Tab', level=Qgis.Info)
    
            #LENGTHS
            # Select the feature with ID 0
            target_feature_id = 1  # Change this to the desired feature ID
            selection_expr = f'"ID" = {target_feature_id}'
            multiPolyLayer.selectByExpression(selection_expr)

            seg = []  # Initialize the list to hold line segment points

            ab = ((self.n-1) * self.lot_Length)  # primary road offset length
            rb = self.long_axis - ab  # remaining distance
            yb = 0 
            #QgsMessageLog.logMessage(f"PRIMARY: Reminder Distributable [rb]: {rb}", 'LandSubdivision:Info. Tab', level=Qgis.Info)
            if rb <= self.lot_Length/2:
                QgsMessageLog.logMessage(f"PRIMARY: Reminder is less than the Lot Length/2", 'LandSubdivision:Info. Tab', level=Qgis.Info)
                yb = rb/self.n  # Primary road offset length for reminder < width
                QgsMessageLog.logMessage(f"PRIMARY: Distributed [yb]: {yb}", 'LandSubdivision:Info. Tab', level=Qgis.Info)

            #x = self.lot_Length + yb

            # Calculate the bearing of line l3 and l1, then the initial points
            a_deg1 = self.pt5.azimuth(self.pt2)
            rads1 = math.radians(a_deg1)
            a_deg2 = self.pt4.azimuth(self.pt3)
            rads2 = math.radians(a_deg2)

            # Calculate the initial points for the first segment
            new_x1 = self.pt5_x + (self.lengthDist * math.sin(rads1)) / (111320 * math.cos(math.radians(self.pt5_y)))
            new_y1 = self.pt5_y + (self.lengthDist * math.cos(rads1)) / 110540
            new_point1 = QgsPointXY(new_x1, new_y1)
            new_x2 = self.pt4_x + (self.lengthDist * math.sin(rads2)) / (111320 * math.cos(math.radians(self.pt4_y)))
            new_y2 = self.pt4_y + (self.lengthDist * math.cos(rads2)) / 110540
            new_point2 = QgsPointXY(new_x2, new_y2)

            # Add the initial segment to the list
            seg.append([new_point2, new_point1])

            # Calculate and add additional line segments to the list
            for i in range(self.n ):
                # Calculate new points for the current segment
                new_x1 = self.pt5_x + ((i + 1) * self.lengthDist * math.sin(rads1)) / (111320 * math.cos(math.radians(self.pt5_y)))
                new_y1 = self.pt5_y + ((i + 1) * self.lengthDist * math.cos(rads1)) / 110540
                new_point1 = QgsPointXY(new_x1, new_y1)
                new_x2 = self.pt4_x + ((i + 1) * self.lengthDist * math.sin(rads2)) / (111320 * math.cos(math.radians(self.pt4_y)))
                new_y2 = self.pt4_y + ((i + 1) * self.lengthDist * math.cos(rads2)) / 110540
                new_point2 = QgsPointXY(new_x2, new_y2)

                # Add the current segments to the list
                seg.append([new_point2, new_point1])

            
            #WIDTHS       
            # Calculate the bearing of line l3 and l1, then the initial points
            a_deg54 = self.pt5.azimuth(self.pt4)
            rads54 = math.radians(a_deg54)
            a_deg78 = self.pt7.azimuth(self.pt8)
            rads78 = math.radians(a_deg78)
            QgsMessageLog.logMessage(f"Pt7 - Pt8 brg: {a_deg78}", 'LandSubdivision:Info. Tab', level = Qgis.Info )
            #QgsMessageLog.logMessage(f"Pt5 - Pt4 brg: {a_deg54}", 'LandSubdivision:Info. Tab', level = Qgis.Info )
            a_deg23 = self.pt2.azimuth(self.pt3)
            rads23 = math.radians(a_deg23)
            a_deg109 = self.pt10.azimuth(self.pt9)
            rads109 = math.radians(a_deg109)
            QgsMessageLog.logMessage(f"Pt10 - Pt9 brg: {a_deg109}", 'LandSubdivision:Info. Tab', level = Qgis.Info)

            #computation on initial offset points(segments) to the right
            new_x11 = self.pt7_x + (self.widthDist * math.sin(rads78)) / (111320 * math.cos(math.radians(self.pt7_y)))
            new_y11 = self.pt7_y + (self.widthDist * math.cos(rads78)) / 110540
            new_point11 = QgsPointXY(new_x11, new_y11)
            new_x21 = self.pt10_x + (self.widthDist * math.sin(rads109)) / (111320 * math.cos(math.radians(self.pt10_y)))
            new_y21 = self.pt10_y + (self.widthDist * math.cos(rads109)) / 110540
            new_point21 = QgsPointXY(new_x21, new_y21)
            # Add the initial segment to the list
            seg.append([new_point21, new_point11])

            # Calculate and add additional segments to the list
            for i in range(self.p):
                # Calculate new points for the current segment
                new_x11 = self.pt7_x + (i * self.widthDist * math.sin(rads78)) / (111320 * math.cos(math.radians(self.pt7_y)))
                new_y11 = self.pt7_y + (i * self.widthDist * math.cos(rads78)) / 110540
                new_point11 = QgsPointXY(new_x11, new_y11)
                new_x21 = self.pt10_x + (i * self.widthDist * math.sin(rads109))/ (111320 * math.cos(math.radians(self.pt10_y)))
                new_y21 = self.pt10_y + (i * self.widthDist * math.cos(rads109)) / 110540
                new_point21 = QgsPointXY(new_x21, new_y21)
                # Add the current segments to the list
                seg.append([new_point21, new_point11])
            
            #computation on initial offset points(segments) to the left
            new_x1L = self.pt5_x + (self.widthDistb * math.sin(rads54)) / (111320 * math.cos(math.radians(self.pt5_y)))
            new_y1L = self.pt5_y + (self.widthDistb * math.cos(rads54)) / 110540
            new_point1L = QgsPointXY(new_x1L, new_y1L)
            new_x2L = self.pt2_x + (self.widthDistb * math.sin(rads23)) / (111320 * math.cos(math.radians(self.pt2_y)))
            new_y2L = self.pt2_y + (self.widthDistb * math.cos(rads23)) / 110540
            new_point2L = QgsPointXY(new_x2L, new_y2L)
            # Add the initial segment to the list
            seg.append([new_point2L, new_point1L])

            # Calculate and add additional segments to the list to the left
            for i in range(self.m):
                # Calculate new points for the current segment
                new_x1L = self.pt5_x + (i * self.widthDistb * math.sin(rads54)) / (111320 * math.cos(math.radians(self.pt5_y)))
                new_y1L = self.pt5_y + (i * self.widthDistb * math.cos(rads54)) / 110540
                new_point1L = QgsPointXY(new_x1L, new_y1L)
                new_x2L = self.pt2_x + (i * self.widthDistb * math.sin(rads23))/ (111320 * math.cos(math.radians(self.pt2_y)))
                new_y2L = self.pt2_y + (i * self.widthDistb * math.cos(rads23)) / 110540
                new_point2L = QgsPointXY(new_x2L, new_y2L)
                # Add the current segments to the list
                seg.append([new_point2L, new_point1L])
            
            # Create the MultiLineString layer and add the features
            mLineLayer = QgsVectorLayer("MultiLineString", 'Split Lineeeeeees', "memory", crs=crs)
            mLineProvider = mLineLayer.dataProvider()
            mLineGeometry = QgsGeometry.fromMultiPolylineXY(seg)
            mLineFeature = QgsFeature()
            mLineFeature.setGeometry(mLineGeometry)
            mLineProvider.addFeatures([mLineFeature])
            QgsProject.instance().addMapLayer(mLineLayer)
            

            div_line = processing.run("native:extendlines",{"INPUT": mLineLayer, "START_DISTANCE":5, "END_DISTANCE":5, "OUTPUT":"TEMPORARY_OUTPUT"})["OUTPUT"]
            #QgsProject.instance().addMapLayer(div_line)        
            blocks = processing.run("native:splitwithlines", {"INPUT":multiPolyLayer, "LINES":div_line, "OUTPUT":"TEMPORARY_OUTPUT"})["OUTPUT"]
            QgsProject.instance().addMapLayer(blocks)
            blockVertices = processing.run("native:extractvertices", {"INPUT":blocks, "OUTPUT":"TEMPORARY_OUTPUT"})["OUTPUT"]
            QgsProject.instance().addMapLayer(blockVertices)
            
            self.blockVertex(blockVertices)
            pv = blocks.dataProvider()
            pv.addAttributes([QgsField("ID", QVariant.Int), QgsField("SIZE", QVariant.Double)])
            blocks.updateFields()
            

            expression = QgsExpression("$id")
            context = QgsExpressionContext()
            context.appendScopes(\
            QgsExpressionContextUtils.globalProjectLayerScopes(blocks))
            
    
            with edit(blocks):
                for f in blocks.getFeatures():
                    context.setFeature(f)
                   # f["SIZE"] = expression1.evaluate(context)
                    f["ID"] = expression.evaluate(context)
                    blocks.updateFeature(f)

            blocks.setLabelsEnabled(True)
            text_format = QgsTextFormat()
            label = QgsPalLayerSettings()
            label.fieldName = 'ID' 
            label.enabled = True
            label.setFormat(text_format)
            label.centroidWhole = True 
            label.centroidWhole = True
            label.placement = QgsPalLayerSettings.OverPoint
            labeler = QgsVectorLayerSimpleLabeling(label)
            blocks.setLabeling(labeler)
            blocks.triggerRepaint()


            QgsMessageLog.logMessage(f"partition Succesfull: 779", 'LandSubdivision:Info. Tab', level=Qgis.Info)
        except QgsProcessingException as r:
            QgsMessageLog.logMessage(f"Error: {r}", 'LandSubdivision:Info. Tab', level=Qgis.Info)
        return mLineLayer, blocks

    def blockVertex(self, blockVertices):
        pr = blockVertices.dataProvider()
        #add field to store coordinates in attribute table
        for attr in ["Latitude", "Longitude"]:
            pr.addAttributes([QgsField(attr, QVariant.Double)])
            blockVertices.updateFields()
        
        #access the features i.e., feat.
        for feat in blockVertices.getFeatures():
            fields = blockVertices.fields()
            attrs = {
                fields.indexFromName("Latitude"):feat.geometry().asPoint()[0],
                fields.indexFromName("Longitude"):feat.geometry().asPoint()[1]
            }
            pr.changeAttributeValues({feat.id(): attrs})
        blockVertices.updateFields()
        #in order to allow the feature expression access the feature’s field values; create a QgsExpressionContext
        exp = QgsExpression('"attr"')
        context = QgsExpressionContext()
        context.setFeature(feat)
        exp.evaluate(context)
        return blockVertices

    def centreline(self):
        layer = self.dlg.cbParcel.currentLayer()
        roadWidth = self.dlg.dsbRoad_Width.value()
        qs = roadWidth/2 
        layerCrs = layer.crs().authid()
        crs = QgsCoordinateReferenceSystem(layerCrs)
        fCord1 = QgsPointXY(self.value1[0], self.value1[1])
        sCord1 = QgsPointXY(self.value2[0], self.value2[1])

        '''     ---ROADS LOGIC---
        if reminder is less than the Lot Length, Subtract two offsets to 
        obtain the end of the road i.e [self.n-2], number of n offsets minus 
        two. Otherwise the length can accomodate another block, and we 
        retain y - initial OFFSET LENGTH

        y  --> {initial OFFSET LENGTH} is equals to the incoming road length offset-end(from Initial POINT)
        r  --> {REMINDER} is equals to the remaining length at the end of subdivision
        a  --> {OFFSET LENGTH}

        '''
        y = ((self.n-1)* self.lengthDist)  # primary road offset length
        #initialise list to hold line segment points
        a_deg = fCord1.azimuth(sCord1)
        rads = math.radians(a_deg)
        a_deg_78 = self.pt7.azimuth(self.pt8)
        rads_78 = math.radians(a_deg_78)
        azDeg52 = self.pt5.azimuth(self.pt2)
        rads52 = math.radians(azDeg52)
        azDeg25 = self.pt2.azimuth(self.pt5) 
        rads25 = math.radians(azDeg25)
        a_deg_54 = self.pt5.azimuth(self.pt4)
        rads_54 = math.radians(a_deg_54)

        roadCoord = []
        rdEndx1 = self.pt5_x + (y * math.sin(rads52)) / (111320 * math.cos(math.radians(self.pt5_y)))
        rdEndy1 = self.pt5_y + (y * math.cos(rads52)) / 110540
        initial = QgsPointXY(self.pt5_x, self.pt5_y)
        endPointRd = QgsPointXY(rdEndx1, rdEndy1)
        roadCoord.append([initial, endPointRd])

        edges1 = []
        edges2 = []
        #the start edges(lengths)
        new_X = self.pt5_x + (qs * math.sin(rads_78)) / (111320 * math.cos(math.radians(self.pt5_y)))
        new_Y = self.pt5_y + (qs * math.cos(rads_78)) / 110540
        newX = self.pt5_x + (qs * math.sin(rads_54)) / (111320 * math.cos(math.radians(self.pt5_y)))
        newY = self.pt5_y + (qs * math.cos(rads_54)) / 110540
        edgeStart = QgsPointXY(new_X, new_Y)
        edgeEnd = QgsPointXY(newX, newY)
        edges1.append([edgeStart, edgeEnd])
        #extreems
        new_X1 = new_X + ((y+qs) * math.sin(rads)) / (111320 * math.cos(math.radians(new_Y)))
        new_Y1 = new_Y + ((y+qs) * math.cos(rads)) / 110540
        newX1 = newX + ((y+qs) * math.sin(rads)) / (111320 * math.cos(math.radians(new_Y)))
        newY1 = newY + ((y+qs) * math.cos(rads)) / 110540

        exStart = QgsPointXY(new_X, new_Y)
        exEnd = QgsPointXY(new_X1, new_Y1)
        exStart2 = QgsPointXY(newX, newY)
        exEnd2 = QgsPointXY(newX1, newY1)
        edges2.append(exStart)
        edges2.append(exStart2)
        edges2.append(exEnd2)
        edges2.append(exEnd)


        #create a centreline layer
        roadLayer = QgsVectorLayer("MultiLineString", 'Centreline', 'memory', crs = crs)
        prov = roadLayer.dataProvider()
        roadGeometry = QgsGeometry.fromMultiPolylineXY(roadCoord)
        roadFeature = QgsFeature()
        roadFeature.setGeometry(roadGeometry)
        prov.addFeatures([roadFeature])
        #label road to red Symbol
        lay = roadLayer
        renderer = lay.renderer()
        symbol = renderer.symbol()
        symbol.setColor(QColor('red'))
        symbol.setWidth(0.5)
        QgsProject.instance().addMapLayer(roadLayer)

        # Calculate the blocks within the Primary Road Offset length
        div = round(y / self.lengthDist)

        # Initialize an empty list to store the offset lot lengths
        lengths = []

        # Check if the division result, div,  is odd or even
        if div % 2 == 1:
            # If odd, create the lengths as length, length*3, length*5
            for i in range(1, div + 1, 2):
                lengths.append(self.lengthDist * i)
        else:
            # If even, create the lengths as length, length*3, length*4
            for i in range(1, div, 2):
                lengths.append(self.lengthDist * i)
            # Add the last value as (length * div)
            lengths.append(self.lengthDist * div)

        QgsMessageLog.logMessage(f"PRIMARY: LengthsLIST: {lengths}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   

        # Create the junction point layer
        junc = QgsVectorLayer("MultiPoint", 'Junction', 'memory', crs=crs)
        p_v = junc.dataProvider()

        juncPoints = []
        for length in lengths:
            # Calculate the junction point coordinates
            rdJunctionX = self.pt5_x + (length * math.sin(rads52)) / (111320 * math.cos(math.radians(self.pt5_y)))
            rdJunctionY = self.pt5_y + (length * math.cos(rads52)) / 110540
            nJunc = QgsPointXY(rdJunctionX, rdJunctionY)
            nJunc1 = (rdJunctionX, rdJunctionY)
            juncPoints.append(nJunc1)
            
            # Create a point feature for the current length
            juncGeom = QgsGeometry.fromPointXY(QgsPointXY(nJunc))
            juncFeature = QgsFeature()
            juncFeature.setGeometry(juncGeom)
            p_v.addFeatures([juncFeature])
        QgsProject.instance().addMapLayer(junc)
        


        '''SERVICE ROADS LENGTHS RIGHT'''
        #logic of road extent.
        a = self.widthDist/2 
        v = ((self.p-1) * self.widthDist)  # primary road offset length to the Right
        QgsMessageLog.logMessage(f"To the RIGHT: primary road offset length [v]: {v}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
        w = self.shortAxis - v  #remaining distance
        QgsMessageLog.logMessage(f"To the RIGHT: Reminder [w]: {w}", 'LandSubdivision:Info. Tab', level = Qgis.Info)

        if w <= self.widthDist/2:
            QgsMessageLog.logMessage(f"To the RIGHT: Reminder is less than the Lot Width/2 ", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            s = ((self.p-2)* self.widthDist) + a  #road offset length for reminder < width
            QgsMessageLog.logMessage(f"To the RIGHT: Primary Road Offset Length [s]: {s}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
        elif w >= self.widthDist/2:
            QgsMessageLog.logMessage(f"To the RIGHT: Reminder is greater than the Lot Width/2 ", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            s = v + a #road offset length for remainder > width 
            QgsMessageLog.logMessage(f"To the RIGHT: Primary Road Offset Length[s+]: {s}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
    

        # Create an empty list to hold the line segments both to the left and to the right
        roadSegments = [] #centreline
        endPoints = [] #endedge
        rdEdges = [] 
        for i in range(len(juncPoints)):
            #Extract the X and Y coordinates from the point
            x, y = juncPoints[i]
            QgsMessageLog.logMessage(f"Road Junction coords Extracted : {x, y}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            # Calculate the new end point coordinates with the sufficient road length 
            new_x = x + (s * math.sin(rads_78)) / (111320 * math.cos(math.radians(y)))
            new_y = y + (s * math.cos(rads_78)) / 110540
            start_point = QgsPointXY(x, y)
            end_point = QgsPointXY(new_x, new_y)
            #roadEdgePoints to the right above & below PRIMARY centeline(juncPoints)
            newX1 = x + (qs * math.sin(rads25)) / (111320 * math.cos(math.radians(y)))
            newY1 = y + (qs * math.cos(rads25)) / 110540
            newX2 = x + (qs * math.sin(rads52)) / (111320 * math.cos(math.radians(y)))
            newY2 = y + (qs * math.cos(rads52)) / 110540
            # Calculate the new road edge, end point coordinates with the sufficient road length 
            new_x1 = newX1 + (s * math.sin(rads_78)) / (111320 * math.cos(math.radians(newY1)))
            new_y1 = newY1 + (s * math.cos(rads_78)) / 110540
            new_x2 = newX2 + (s * math.sin(rads_78)) / (111320 * math.cos(math.radians(newY2)))
            new_y2 = newY2 + (s * math.cos(rads_78)) / 110540 
            startEdge = QgsPointXY(newX1, newY1)
            endEdge = QgsPointXY(new_x1, new_y1)
            startEdge1 = QgsPointXY(newX2, newY2)
            endEdge1 = QgsPointXY(new_x2, new_y2)

            #Append the line segment to the list
            roadSegments.append([start_point, end_point]) 
            endPoints.append(end_point)
            rdEdges.append(startEdge)
            rdEdges.append(startEdge1)
            rdEdges.append(endEdge1)
            rdEdges.append(endEdge)
            #edges.append([startEdge1, endEdge1])
        
        

        '''SERVICE ROADS LENGTHS LEFT'''

        #logic of road extent.
        a2 = self.widthDistb/2
        q = ((self.m-1)* self.widthDistb)  # primary road offset length to the left
        QgsMessageLog.logMessage(f"To_the_LEFT: primary road offset length [q]: {q}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
        t = self.short_axis - q  #remaining distance
        QgsMessageLog.logMessage(f"To_the_LEFT: Reminder[t]: {t}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
        if t <= self.widthDistb/2:
            QgsMessageLog.logMessage(f"To_the_LEFT: Reminder is less than the Lot Width/2", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            j = ((self.m-2)* self.widthDistb) + a2 #road offset length for reminder < width
            QgsMessageLog.logMessage(f"To_the_LEFT: Primary Road Offset Length: {j}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
        elif t >= self.widthDistb/2:
            QgsMessageLog.logMessage(f"To_the_LEFT: Reminder is greater than the Lot Width/2", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            j = ((self.m-1)* self.widthDistb) + a2 #road offset length for remainder > width 
            QgsMessageLog.logMessage(f"To_the_LEFT: Primary Road Offset Length: {j}", 'LandSubdivision:Info. Tab', level = Qgis.Info)
    
    
        for i in range(len(juncPoints)):
            #Extract the X and Y coordinates from the point
            x, y = juncPoints[i]
            QgsMessageLog.logMessage(f"Road Junction coords Extracted : {x, y}", 'LandSubdivision:Info. Tab', level = Qgis.Info)   
            # Calculate the new point coordinates with the sufficient road Length
            new_x = x + (j * math.sin(rads_54)) / (111320 * math.cos(math.radians(y)))
            new_y = y + (j * math.cos(rads_54)) / 110540
            start_point = QgsPointXY(x, y)
            end_point = QgsPointXY(new_x, new_y)
            #to the left edges(lengths)
            newXA = x + (qs * math.sin(rads25)) / (111320 * math.cos(math.radians(y)))
            newYA = y + (qs * math.cos(rads25)) / 110540
            newXB = x + (qs * math.sin(rads52)) / (111320 * math.cos(math.radians(y)))
            newYB = y + (qs * math.cos(rads52)) / 110540
            # Calculate the new road edge, end point coordinates with the sufficient road length 
            new_xa = newXA + (j * math.sin(rads_54)) / (111320 * math.cos(math.radians(newYA)))
            new_ya = newYA + (j * math.cos(rads_54)) / 110540
            new_xb = newXB + (j * math.sin(rads_54)) / (111320 * math.cos(math.radians(newYB)))
            new_yb = newYB + (j * math.cos(rads_54)) / 110540 
            startEdge = QgsPointXY(newXA, newYA)
            endEdge = QgsPointXY(new_xa, new_ya)
            startEdge1 = QgsPointXY(newXB, newYB)
            endEdge1 = QgsPointXY(new_xb, new_yb)

            #Append the line segment to the list
            roadSegments.append([start_point, end_point]) 
            endPoints.append(end_point)
            rdEdges.append(startEdge)
            rdEdges.append(startEdge1)
            rdEdges.append(endEdge1)
            rdEdges.append(endEdge)


        #Add the line segments as features to the layer 
        for line in roadSegments:
            geom = QgsGeometry.fromMultiPolylineXY(roadSegments)
            rdFeature = QgsFeature()
            rdFeature.setGeometry(geom)
            prov.addFeatures([rdFeature])
            lay = roadLayer
            renderer = lay.renderer()
            symbol = renderer.symbol()
            symbol.setColor(QColor('red'))
            symbol.setWidth(0.5)
        #Add the layer to the project
        QgsProject.instance().addMapLayer(roadLayer)

        
        #create a Road polygon layer
        roadPoly = QgsVectorLayer("Polygon", 'Barabara.', 'memory', crs = crs)
        provi = roadPoly.dataProvider()
        #Iterate over the juncpoints and create a polygon for each set of four points
        for i in range(0, len(rdEdges), 4):
            points = []
            points.append(rdEdges[i])
            points.append(rdEdges[i+1])
            points.append(rdEdges[i+2])
            points.append(rdEdges[i+3])
            geom = QgsGeometry.fromPolygonXY([points])
            rdPoint = QgsFeature()
            rdPoint.setGeometry(geom)
            provi.addFeatures([rdPoint])

        geom = QgsGeometry.fromPolygonXY([edges2])
        priRoad = QgsFeature()
        priRoad.setGeometry(geom)
        provi.addFeatures([priRoad])
    
        #Add the layer to the project
        QgsProject.instance().addMapLayer(roadPoly)


        '''TRUNCATION'''
        trunc = []
        for i in range(len(juncPoints)):
            #Extract the X and Y coordinates from the point
            x, y = juncPoints[i]
            #Calculate the trucation vertex
            new_x = x + (qs * math.sin(rads25)) / (111320 * math.cos(math.radians(y)))
            new_y = y + (qs * math.cos(rads25)) / 110540
            new_xa = new_x + (qs * math.sin(rads_78)) / (111320 * math.cos(math.radians(y)))
            new_ya = new_y + (qs * math.cos(rads_78)) / 110540
            new_xb = new_xa + (qs * math.sin(rads25)) / (111320 * math.cos(math.radians(y)))
            new_yb = new_ya + (qs * math.cos(rads25)) / 110540
            new_xc = new_xa + (qs * math.sin(rads_78)) / (111320 * math.cos(math.radians(y)))
            new_yc = new_ya + (qs * math.cos(rads_78)) / 110540
            cornera = QgsPointXY(new_xa, new_ya)
            cornerb = QgsPointXY(new_xb, new_yb)
            cornerc = QgsPointXY(new_xc, new_yc)
            trunc.append(cornera)
            trunc.append(cornerb)
            trunc.append(cornerc)

            
            new_xab = new_x + (qs * math.sin(rads_54)) / (111320 * math.cos(math.radians(y)))
            new_yab = new_y + (qs * math.cos(rads_54)) / 110540
            new_xbb = new_xab + (qs * math.sin(rads25)) / (111320 * math.cos(math.radians(y)))
            new_ybb = new_yab + (qs * math.cos(rads25)) / 110540
            new_xcb = new_xab + (qs * math.sin(rads_54)) / (111320 * math.cos(math.radians(y)))
            new_ycb = new_yab + (qs * math.cos(rads_54)) / 110540
            cornerab = QgsPointXY(new_xab, new_yab)
            cornerbb = QgsPointXY(new_xbb, new_ybb)
            cornercb = QgsPointXY(new_xcb, new_ycb)
            trunc.append(cornerab)
            trunc.append(cornerbb)
            trunc.append(cornercb)
        for i in range(len(juncPoints)-1):
            #Extract the X and Y coordinates from the point
            x, y = juncPoints[i]
            #Calculate the trucation vertex
            new_x = x + (qs * math.sin(rads52)) / (111320 * math.cos(math.radians(y)))
            new_y = y + (qs * math.cos(rads52)) / 110540
            new_xa = new_x + (qs * math.sin(rads_78)) / (111320 * math.cos(math.radians(y)))
            new_ya = new_y + (qs * math.cos(rads_78)) / 110540
            new_xb = new_xa + (qs * math.sin(rads52)) / (111320 * math.cos(math.radians(y)))
            new_yb = new_ya + (qs * math.cos(rads52)) / 110540
            new_xc = new_xa + (qs * math.sin(rads_78)) / (111320 * math.cos(math.radians(y)))
            new_yc = new_ya + (qs * math.cos(rads_78)) / 110540
            cornera = QgsPointXY(new_xa, new_ya)
            cornerb = QgsPointXY(new_xb, new_yb)
            cornerc = QgsPointXY(new_xc, new_yc)
            trunc.append(cornera)
            trunc.append(cornerb)
            trunc.append(cornerc)

            
            new_xab = new_x + (qs * math.sin(rads_54)) / (111320 * math.cos(math.radians(y)))
            new_yab = new_y + (qs * math.cos(rads_54)) / 110540
            new_xbb = new_xab + (qs * math.sin(rads52)) / (111320 * math.cos(math.radians(y)))
            new_ybb = new_yab + (qs * math.cos(rads52)) / 110540
            new_xcb = new_xab + (qs * math.sin(rads_54)) / (111320 * math.cos(math.radians(y)))
            new_ycb = new_yab + (qs * math.cos(rads_54)) / 110540
            cornerab = QgsPointXY(new_xab, new_yab)
            cornerbb = QgsPointXY(new_xbb, new_ybb)
            cornercb = QgsPointXY(new_xcb, new_ycb)
            trunc.append(cornerab)
            trunc.append(cornerbb)
            trunc.append(cornercb)


        #create a truncation polygon layer
        # truncLayer = QgsVectorLayer("Polygon", 'Truncation', 'memory', crs=crs)
        # provt = truncLayer.dataProvider()
        #Iterate over the juncpoints and create a polygon for each set of 3 points
        for i in range(0, len(trunc), 3):
            points = []
            points.append(trunc[i])
            points.append(trunc[i+1])
            points.append(trunc[i+2])          
            geom = QgsGeometry.fromPolygonXY([points])
            feat = QgsFeature()
            feat.setGeometry(geom)
            provi.addFeatures([feat])
        #QgsProject.instance().addMapLayer(truncLayer)

        '''CHECKS'''
        azim = self.pt8.azimuth(self.pt5)
        azima = self.pt9.azimuth(self.pt2)
        azimb = self.pt9.azimuth(self.pt8)
        azimc = self.pt3.azimuth(self.pt4)
        QgsMessageLog.logMessage(f"Bearing of Point 8 - Point 5: {azim}", 'CHECK', level = Qgis.Info)
        QgsMessageLog.logMessage(f"Bearing of Point 9 - Point 2: {azima}", 'CHECK', level = Qgis.Info)
        QgsMessageLog.logMessage(f"Bearing of Point 9 - Point 8: {azimb}", 'CHECK', level = Qgis.Info)
        QgsMessageLog.logMessage(f"Bearing of Point 3 - Point 4: {azimc}", 'CHECK', level = Qgis.Info)
        are = self.lengthDist * self.widthDist 
        are2 = self.lengthDist * self.widthDistb
        ar = are/10000
        ar1 = are2/10000
        QgsMessageLog.logMessage(f"Parcel Areas to the right: {are:4f}sqm; approx: {ar:4f} ha", 'CHECK', level = Qgis.Info)
        QgsMessageLog.logMessage(f"Parcel Areas to the left: {are2:4f}sqm; approx:{ar1:4f} ha" 'CHECK', level = Qgis.Info)

        return roadLayer

    def run(self):
        """Run method that performs all the real work"""
        #self.canvas.setMapTool(self.mapTool)
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is starteds
        if self.first_start == True:
            self.first_start = False
            self.dlg = SubDivDialog()

            #self.dlg = LandSubdivisionDialog()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            self.acresToSqm()
            self.calculate_Length()
            blocks = self.blockPartition()
            
            
            
            
            

            